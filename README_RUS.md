# NSUEM-PDS_HW

## Lecture 1

![lecture_1](https://skillicons.dev/icons?i=cpp)

▎Описание проекта

Этот репозиторий содержит реализацию абстрактных структур данных на языке C++: стек, очередь, список и множество. Все структуры данных реализованы на основе массивов и поддерживают основные операции.

▎Стек

Стек реализован на основе массива и включает следующие операции:

- push(value) — добавляет элемент на вершину стека.
- pop() — удаляет элемент с вершины стека.
- last() — возвращает элемент на вершине стека без его удаления.
- isEmpty() — проверяет, пуст ли стек.
- print() — выводит содержимое стека.

▎Очередь

Очередь реализована на основе массива с использованием сдвига элементов. Поддерживаемые операции:

- enqueue(value) — добавляет элемент в конец очереди.
- dequeue() — удаляет элемент из начала очереди.
- first() — возвращает первый элемент очереди без его удаления.
- isEmpty() — проверяет, пуста ли очередь.
- print() — выводит содержимое очереди.

▎Список

Список реализован на основе массива и поддерживает операции добавления и удаления элементов с учетом сдвига:

- add(value) — добавляет элемент в список.
- remove(index) — удаляет элемент по индексу.
- print() — выводит содержимое списка.

▎Множество

Множество реализовано на основе массива с пометкой элементов. Основные операции:

- add(value) — добавляет элемент в множество (если его еще нет).
- remove(value) — удаляет элемент из множества (если он существует).
- contains(value) — проверяет, содержится ли элемент в множестве.
- print() — выводит содержимое множества.

## lecture 2

![lecture_2](https://skillicons.dev/icons?i=cpp)

- `linear_search.h`: реализация последовательного поиска элементов в массиве.
- `binary_search.h`: реализация двоичного поиска элементов в массиве.
- `search_comparison.h`: реализация сравнения сложности алгоритмов поиска.
- `main.cpp`: основная программа, которая демонстрирует работу алгоритмов поиска.

## Описание алгоритмов

- **Последовательный поиск**: этот алгоритм работает путем последовательного просмотра элементов массива и сравнения каждого элемента с искомым значением. Если элемент найден, алгоритм возвращает индекс элемента.
- **Двоичный поиск**: этот алгоритм работает путем деления массива на две части и сравнения среднего элемента с искомым значением. Если средний элемент равен искомому значению, алгоритм возвращает индекс элемента. Если средний элемент меньше искомого значения, алгоритм повторяется для правой части массива. Если средний элемент больше искомого значения, алгоритм повторяется для левой части массива.

## lecture 3

![lecture_3](https://skillicons.dev/icons?i=cpp)

▎Измерение Производительности и Визуализация

Этот раздел кода предназначен для измерения производительности различных алгоритмов для проверки, является ли число простым, и для вычисления наибольшего общего делителя (НОД). Результаты затем визуализируются с помощью цветных фонов, чтобы указать относительную производительность каждого алгоритма.

## lecture 4

![lecture_4](https://skillicons.dev/icons?i=go)

- **Рекурсивные Функции**

Это программа, демонстрирующая использование рекурсивных функций в различных сценариях. Программа включает тесты для различных рекурсивных функций, а также тесты времени для сравнения производительности рекурсивных и итеративных функций.

Программа включает три пакета с рекурсивными функциями:

- `RecursiveFunc`: Этот пакет содержит рекурсивные функции для вычисления суммы цифр числа, суммы чисел от 0 до заданного числа, числа Фибоначчи в заданной позиции и факториала числа.

- `RecursiveProc`: Этот пакет содержит рекурсивные процедуры для вывода чисел от 1 до заданного числа, от заданного числа до 1 и от -заданного числа до заданного числа.

- `RecursiveFromTwoArgs`: Этот пакет содержит рекурсивные функции для вычисления алгоритма Евклида, степени числа и факториала числа.

- **Тесты Времени**

Программа включает тесты времени для сравнения производительности рекурсивных и итеративных функций. Тесты измеряют время, необходимое для вычисления числа Фибоначчи в заданной позиции с помощью различных подходов:

- `Fibonacci`: Рекурсивная функция без оптимизации
- `FibonacciMemoized`: Рекурсивная функция с кэшированием
- `FibonacciIterativeArray`: Итеративная функция с временным массивом
- `FibonacciIterativeOnTheFly`: Итеративная функция с вычислением на лету

## Установка

1. Клонируйте репозиторий:

   ```bash
   git clone https://github.com/freeeakn/NSUEM-PDS_HW
   cd NSUEM-PDS_HW
   ```

2. Скомпилируйте проект:

      ```bash
      make
      ```

▎Использование

Пример использования каждой структуры данных можно найти в файле main.cpp.

## Автор

Программа была разработана студентом третьего курса Печёнкиным Артуром в рамках курса по дисциплине: "Программирование дискретных структур", на языке C++ и Golang.

Контактная информация:

- Артур [@machinee](https://github.com/freeeakn)

## Лицензия

Этот проект лицензирован под лицензией MIT. Пожалуйста, ознакомьтесь с файлом LICENSE для получения дополнительной информации.

---

## Примечание

- ***Убедитесь, что у вас установлен компилятор C++ (например, g++) для компиляции и запуска проекта.***
- ***Убедитесь, что у вас установлен компилятор golang (go) для запуска проекта.***
